<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Dino Warp - Golden Record Edition</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            display: flex; flex-direction: column; justify-content: center; align-items: center; 
            min-height: 100vh; font-family: 'Courier New', Courier, monospace; 
            overflow: hidden; touch-action: none; background-color: #f7f7f7;
        }
        #container { 
            position: relative; width: 800px; height: 350px; 
            background-color: transparent; overflow: hidden;
        }
        canvas { display: block; width: 100%; height: 100%; }
    </style>
</head>
<body id="gameBody">
    <div id="container">
        <canvas id="gameCanvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 800; canvas.height = 350;

        // --- FOLDER PATHS ---
        const imgPath = 'images/'; 
        const audPath = 'audio/';

        const dinoImg = new Image(); dinoImg.src = imgPath + 'Screenshot_2025-12-27-14-38-59-263_com.android.chrome-edit.jpg';
        const cactusImg = new Image(); cactusImg.src = imgPath + 'Screenshot_2025-12-27-14-52-08-378_com.android.chrome-edit.jpg';

        const snd1k = new Audio(audPath + 'aplausos_2.mp3');
        const snd10k = new Audio(audPath + '-audiotrimmer_adesehy.mp3');
        const sndGameOver = new Audio(audPath + 'directed-by-robert-b_voI2Z4T.mp3');
        
        let milestones = { m1k: false, m10k: false };
        let highScore = localStorage.getItem('dinoHighScore') || 0;
        let isNewRecord = false;

        const GRAVITY = 0.6;
        const JUMP_FORCE = -12;
        const GROUND_Y = 220;
        let gameSpeed = 5; 
        let score = 0;
        let isGameOver = false;
        let gameStarted = false;
        let obstacles = [], clouds = [], stars = [];
        let frameCount = 0;
        
        let canFly = false, isInvincible = false, isDucking = false;
        let spaceCount = 0, lastSpaceTime = 0, boomRadius = 0, lightningFlash = 0;

        for(let i=0; i<40; i++) stars.push({ x: Math.random() * canvas.width, y: Math.random() * 180, size: Math.random() * 2 });
        for(let i=0; i<6; i++) clouds.push({ x: Math.random() * canvas.width, y: 30 + Math.random() * 80, s: 0.2 + Math.random() * 0.4 });

        function getSkyColor(cycle) {
            if (lightningFlash > 0) return `rgb(220, 220, 255)`;
            const r = Math.floor(247 - (cycle * (247 - 20)));
            const g = Math.floor(247 - (cycle * (247 - 20)));
            const b = Math.floor(247 - (cycle * (247 - 40)));
            return `rgb(${r}, ${g}, ${b})`;
        }

        function drawUI(s, isNight) {
            ctx.save();
            ctx.textAlign = "right";
            ctx.font = "bold 20px Courier New";

            // High Score Glow Logic
            if (s > highScore && s > 0) {
                isNewRecord = true;
                highScore = s;
                localStorage.setItem('dinoHighScore', highScore);
            }

            if (isNewRecord) {
                const glow = Math.sin(frameCount / 5) * 10 + 15;
                ctx.shadowBlur = glow;
                ctx.shadowColor = "#FFD700";
                ctx.fillStyle = "#D4AF37"; // Golden color
            } else {
                ctx.fillStyle = isNight ? "#DDD" : "#535353";
            }

            ctx.fillText(`HI ${highScore.toString().padStart(6, '0')} ${s.toString().padStart(6, '0')}`, canvas.width - 20, 40);
            
            // Speedometer
            ctx.textAlign = "left";
            const speedVal = Math.floor(gameSpeed * 12);
            if (canFly) {
                ctx.shadowBlur = 10;
                ctx.shadowColor = "#ff0000";
                ctx.fillStyle = "#ff0000";
                ctx.fillText(`SPEED: ${speedVal} KM/H [WARP]`, 20, canvas.height - 20);
            } else {
                ctx.shadowBlur = 0;
                ctx.fillStyle = isNight ? "#DDD" : "#535353";
                ctx.fillText(`SPEED: ${speedVal} KM/H`, 20, canvas.height - 20);
            }
            ctx.restore();
        }

        function animate() {
            if (isGameOver) return;
            frameCount++;
            score += canFly ? 40 : 0.25; 
            let s = Math.floor(score);

            if (s >= 1000 && !milestones.m1k) { snd1k.play(); milestones.m1k = true; }
            if (s >= 10000 && !milestones.m10k) { snd10k.play(); milestones.m10k = true; }

            let cycle = (Math.sin((score / 2000) * Math.PI - (Math.PI / 2)) + 1) / 2;
            let isNight = cycle > 0.6;
            if (isNight && Math.random() > 0.993) lightningFlash = 4;
            if (lightningFlash > 0) lightningFlash--;

            document.body.style.backgroundColor = getSkyColor(cycle);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Background Elements
            const angle = (cycle * Math.PI) + Math.PI;
            const sunX = 400 + Math.cos(angle) * 340, sunY = 180 + Math.sin(angle) * 140;
            const moonX = 400 + Math.cos(angle + Math.PI) * 340, moonY = 180 + Math.sin(angle + Math.PI) * 140;

            if (cycle > 0.4) {
                ctx.globalAlpha = (cycle - 0.4) * 2;
                ctx.fillStyle = "white";
                stars.forEach(st => { ctx.fillRect(st.x, st.y, st.size, st.size); st.x -= 0.1; if(st.x < 0) st.x = canvas.width; });
                ctx.globalAlpha = 1.0;
            }
            ctx.fillStyle = "#FFD700"; ctx.beginPath(); ctx.arc(sunX, sunY, 25, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = "#EEE"; ctx.beginPath(); ctx.arc(moonX, moonY, 22, 0, Math.PI*2); ctx.fill();

            clouds.forEach(c => {
                ctx.fillStyle = cycle > 0.6 ? "rgba(70,70,70,0.8)" : "rgba(220,220,220,0.8)";
                ctx.beginPath(); ctx.arc(c.x, c.y, 15, 0, Math.PI*2); ctx.arc(c.x+15, c.y-10, 20, 0, Math.PI*2); ctx.fill();
                c.x -= c.s * (canFly ? 15 : 1); if(c.x < -60) c.x = canvas.width + 20;
            });

            ctx.strokeStyle = (isNight && lightningFlash === 0) ? "#DDD" : "#535353";
            ctx.beginPath(); ctx.moveTo(0, GROUND_Y + 45); ctx.lineTo(canvas.width, GROUND_Y + 45); ctx.stroke();

            gameSpeed += canFly ? 0.25 : 0.0025;
            if (frameCount % 60 === 0) obstacles.push(new Obstacle());

            // Dino Physics
            if (!canFly) { dino.dy += GRAVITY; dino.y += dino.dy; if (dino.y > GROUND_Y) { dino.y = GROUND_Y; dino.dy = 0; } }
            let drawH = isDucking ? 25 : 45, drawY = isDucking ? dino.y + 20 : dino.y;
            
            if (dinoImg.complete) {
                if (isNight && lightningFlash === 0) ctx.filter = 'invert(1)';
                ctx.drawImage(dinoImg, 50, drawY, 45, drawH);
                ctx.filter = 'none';
            }

            obstacles = obstacles.filter(obs => {
                obs.update(isNight && lightningFlash === 0);
                if (!isInvincible && 50 < obs.x + obs.width - 8 && 50 + 35 > obs.x + 8 && (isDucking ? dino.y + 20 : dino.y) < obs.y + obs.height - 5 && (dino.y + 45) > obs.y + 5) {
                    isGameOver = true; sndGameOver.play();
                }
                return obs.x > -50;
            });

            drawUI(s, isNight && lightningFlash === 0);

            if (isGameOver) { 
                ctx.textAlign = "center"; ctx.fillStyle = isNight ? "#DDD" : "#535353";
                ctx.fillText("GAME OVER - PRESS R", canvas.width / 2, 160); 
            } else { 
                requestAnimationFrame(animate); 
            }
        }

        class Obstacle {
            constructor() {
                this.type = Math.random() > 0.7 ? 'bird' : 'cactus';
                this.x = canvas.width;
                this.width = this.type === 'cactus' ? 32 : 42;
                this.height = this.type === 'cactus' ? 46 : 18;
                this.y = this.type === 'cactus' ? GROUND_Y : [GROUND_Y - 120, GROUND_Y - 60, GROUND_Y + 20][Math.floor(Math.random() * 3)];
            }
            update(isNight) {
                this.x -= gameSpeed;
                if (this.type === 'cactus' && cactusImg.complete) {
                    if (isNight) ctx.filter = 'invert(1)';
                    ctx.drawImage(cactusImg, this.x, this.y, this.width, this.height);
                    ctx.filter = 'none';
                } else if (this.type === 'bird') {
                    ctx.fillStyle = isNight ? "#DDD" : "#535353";
                    ctx.fillRect(this.x, this.y, this.width, 10);
                    ctx.fillRect(this.x + 8, (Math.floor(frameCount / 8) % 2 === 0 ? this.y - 15 : this.y + 10), 12, 12);
                }
            }
        }

        const dino = { y: GROUND_Y, dy: 0 };

        window.addEventListener('keydown', e => {
            if (e.code === 'Space' || e.code === 'ArrowUp') {
                if (!gameStarted) { gameStarted = true; animate(); }
                if (!canFly && dino.y >= GROUND_Y && !isDucking) dino.dy = JUMP_FORCE;
                if (e.code === 'Space') {
                    let now = Date.now();
                    if (now - lastSpaceTime < 300) spaceCount++; else spaceCount = 1;
                    lastSpaceTime = now;
                    if (spaceCount >= 3 && !canFly) { canFly = true; isInvincible = true; gameSpeed = 60; boomRadius = 1; }
                }
            }
            if (e.code === 'ArrowDown') isDucking = true;
            if (e.code === 'KeyR') window.location.reload();
            if (canFly) {
                if (e.code === 'ArrowUp') dino.y -= 55;
                if (e.code === 'ArrowDown') dino.y += 55;
            }
        });
        window.addEventListener('keyup', e => { if (e.code === 'ArrowDown') isDucking = false; });
        
        ctx.fillStyle = "#535353"; ctx.textAlign = "center"; ctx.font = "bold 18px Courier New";
        ctx.fillText("TRIPLE SPACE FOR WARP FLIGHT", canvas.width / 2, 175);
    </script>
</body>
</html>
